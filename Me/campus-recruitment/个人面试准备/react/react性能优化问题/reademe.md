# React 性能优化

  > 影响网页性能最大的因素是浏览器的重绘和排版，React的 Virtual DOM 就是为了尽量减少浏览器的重绘和重排版。要优化性能，就需要提高 Virtual DOM 的效率。结合React的渲染过程来看，就是要 防止不必要的渲染. 

  ## 一、PureRender
  > React提供了一个便捷方法：PureRender。要理解PureRender中的Pure，首先需要理解纯函数

  纯函数的三大原则：

  - 给定相同的输入，总是返回相同的输出。
  - 过程没有副作用：在纯函数中不能改变外部状态
  - 没有额外的状态依赖：方法内的状态都只在方法的生命周期内存活，意味着我们不能在方法内使用共享变量

  **PureRender的本质**是：重新实现了shouldComponentUpdate生命周期方法，让当前传入的props和state与之前的作 浅比较，如果返回false,组件就不执行render方法

  ### 优化PureRender
  > 浅比较可以覆盖的场景并不太多，当props或state中有以下几种情况时，无论如何都会触发PuerRender为true（触发组件重新渲染

  - 1.直接将props值设置为对象或数组
  例如：
  ```js
  <Comp style={{ color: 'red' }} />
  ```
  实际上在React中，每次调用React组件其实都会创建新的组件。因此，就算每次传入的对象或数组的值是相同的，它们的引用地址却是不一样的。也即是说，上面示例中每次渲染的style其实都是一个新的对象。为style prop设置一个默认值（空对象）也是同样的道理:
  ```js
  <Comp style={ this.props.style || {} } />
  ```
    - 优化方案
      提前赋值成常量，不直接使用字面量即可
    ```js
    const defaultStyle = {} ;
    <Comp style={ this.props.style || defaultStyle } />
    ```

## 二、Immutable

  > 在传递数据时，可以直接使用Immutable Data来进一步提升组件的渲染性能。Js中的对象一般是可变的（mutable），因为使用了引用赋值，新的对象简单引用了原始对象，改变新的对象会影响到原始对象。使用引用赋值是为了节约内存，但当应用复杂后，就造成了非常大的隐患。为了解决这个问题，一般的做法是使用深拷贝或浅拷贝来避免被修改，但这样又会造成CPU和内存的浪费。Immutable可以很好的解决这些问题

  #### Immutable Data
  1. Immutable Data就是一旦创建，就不能更改的数据。对Immutable对象进行修改、添加或删除操作，都会返回一个新的Immutable对象

  2. **Immutable的原理**：持久化的数据结构，即：使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点复制一遍带来的性能损耗，Immutable使用了结构共享，即：如果对象树中的一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享

  ### 2、Immutable的优缺点
  - 优点：
    降低了“可变”带来的复杂性：值不可变。
    节省内存：使用共享结构尽量复用内存，没有被引用的对象会被垃圾回收。
    非常便于实现撤销/重做、粘贴/复制、时间旅行等功能：因为每次数据都是不一样的，只要把这些数据放在一个数组中存储起来，想回退到哪里，就拿出对应的数据，很容易开发撤销/重做功能。
    并发安全：数据不可变，就不再需要并发锁。
    拥抱函数式编程：Immutable本身就是函数式编程中的概念。只要输入一致，输出必然一致。这样开发的组件便于调试和组装。
  - 缺点：
    Immutable最大的问题就是：容易与原生对象发生混淆。虽然Immutable已经尽量把API设计得与原生对象相似，但还是很难区分 Immutable对象 还是 原生对象。

    Immutable中的 Map 与 List 虽然对应的是 JS 中的 Object 和 Array，但操作完全不同。比如取值时要用 map.get('key') 而非 map.key ,要用 array.get(0) 而非array[0]。另外，Immutable每次修改都会返回新对象，很容易忘记赋值。

    使用第三方库时，一般需要使用原生对象，同样容易忘记转换对象

## 无状态组件
  > 这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件


  [参考一](https://segmentfault.com/a/1190000007811296)
  [参考二](https://www.jianshu.com/p/a65f3f1b9a82)
  [参考三](https://www.jianshu.com/p/333f390f2e84)